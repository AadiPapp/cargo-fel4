use std::io::Write;

use common::Error;

pub struct Generator<'a, W: Write + 'a> {
    writer: &'a mut W,
}

impl<'a, W: Write> Generator<'a, W> {
    pub fn new(writer: &'a mut W) -> Self
    where
        W: Write,
    {
        Self { writer }
    }

    pub fn generate(&mut self, pkg_name: &str) -> Result<(), Error> {
        self.write_line("// NOTE: this file is generated by fel4!")?;
        self.write_line("// NOTE: Don't edit it here; your changes will be lost at the next build!")?;
        self.write_line("#![no_std]")?;
        self.write_line("#![feature(global_allocator)]")?;
        self.write_line("")?;
        self.write_line("extern crate sel4_entry;")?;
        self.write_line("extern crate sel4_sys;")?;
        self.write_line("extern crate static_heap;")?;
        self.write_line("")?;
        self.write_line(&format!("extern crate {};", pkg_name))?;
        self.write_line("")?;
        self.write_line("use core::mem;")?;
        self.write_line("use sel4_sys::*;")?;
        self.write_line("use static_heap::*;")?;
        self.write_line("")?;
        self.write_line("#[global_allocator]")?;
        self.write_line("static ALLOCATOR: StaticAlloc = StaticAlloc {};")?;
        self.write_line("")?;
        self.write_line("// include the seL4 kernel configurations")?;
        self.write_line(
            "include!(concat!(env!(\"OUT_DIR\"), \"/sel4_config.rs\"));",
        )?;
        self.write_line("")?;
        self.write_line("#[cfg(feature = \"KERNEL_DEBUG_BUILD\")]")?;
        self.write_line("#[inline(always)]")?;
        self.write_line("pub fn debug_halt() {")?;
        self.write_line("    unsafe { sel4_sys::seL4_DebugHalt() };")?;
        self.write_line("}")?;
        self.write_line("")?;
        self.write_line("fn get_untyped(info: &seL4_BootInfo, size_bytes: usize) -> Option<seL4_CPtr> {")?;
        self.write_line("    let mut idx = 0;")?;
        self.write_line("    for i in info.untyped.start..info.untyped.end {")?;
        self.write_line(
            "        if (1 << info.untypedList[idx].sizeBits) >= size_bytes {",
        )?;
        self.write_line("            return Some(i);")?;
        self.write_line("        }")?;
        self.write_line("        idx += 1;")?;
        self.write_line("    }")?;
        self.write_line("    None")?;
        self.write_line("}")?;
        self.write_line("")?;
        self.write_line("const CHILD_STACK_SIZE: usize = 512;")?;
        self.write_line(
            "static mut CHILD_STACK: *const [u64; CHILD_STACK_SIZE] =",
        )?;
        self.write_line("    &[0; CHILD_STACK_SIZE];")?;
        self.write_line("")?;
        self.write_line("fn main() {")?;
        self.write_line(
            "    unsafe { static_heap::switch_to_static_heap() };",
        )?;
        self.write_line(
            "    let bootinfo = unsafe { &*sel4_entry::BOOTINFO };",
        )?;
        self.write_line("    let cspace_cap = seL4_CapInitThreadCNode;")?;
        self.write_line("    let pd_cap = seL4_CapInitThreadVSpace;")?;
        self.write_line("    let tcb_cap = bootinfo.empty.start;")?;
        self.write_line(
            "    let untyped = get_untyped(bootinfo, 1 << seL4_TCBBits).unwrap();",
        )?;
        self.write_line("    let _: u32 = unsafe {")?;
        self.write_line("        seL4_Untyped_Retype(")?;
        self.write_line("            untyped,")?;
        self.write_line("            api_object_seL4_TCBObject.into(),")?;
        self.write_line("            seL4_TCBBits.into(),")?;
        self.write_line("            cspace_cap.into(),")?;
        self.write_line("            cspace_cap.into(),")?;
        self.write_line("            seL4_WordBits.into(),")?;
        self.write_line("            tcb_cap,")?;
        self.write_line("            1,")?;
        self.write_line("        )")?;
        self.write_line("    };")?;
        self.write_line("    let _: u32 = unsafe {")?;
        self.write_line("        seL4_TCB_Configure(")?;
        self.write_line("            tcb_cap,")?;
        self.write_line("            seL4_CapNull.into(),")?;
        self.write_line("            cspace_cap.into(),")?;
        self.write_line("            seL4_NilData.into(),")?;
        self.write_line("            pd_cap.into(),")?;
        self.write_line("            seL4_NilData.into(),")?;
        self.write_line("            0,")?;
        self.write_line("            0,")?;
        self.write_line("        )")?;
        self.write_line("    };")?;
        self.write_line(
            "    let stack_base = unsafe { CHILD_STACK as usize };",
        )?;
        self.write_line("    let stack_top = stack_base + CHILD_STACK_SIZE;")?;
        self.write_line(
            "    let mut regs: seL4_UserContext = unsafe { mem::zeroed() };",
        )?;
        self.write_line(&format!(
            "    regs.rip = {}::run as seL4_Word;",
            pkg_name
        ))?;
        self.write_line("    regs.rsp = stack_top as seL4_Word;")?;
        self.write_line("    let _: u32 =")?;
        self.write_line("        unsafe { seL4_TCB_WriteRegisters(tcb_cap, 0, 0, 2, &mut regs) };")?;
        self.write_line("    let _: u32 = unsafe {")?;
        self.write_line("        seL4_TCB_SetPriority(tcb_cap, seL4_CapInitThreadTCB.into(), 255)")?;
        self.write_line("    };")?;
        self.write_line(
            "    let _: u32 = unsafe { seL4_TCB_Resume(tcb_cap) };",
        )?;
        self.write_line("    loop {")?;
        self.write_line("        unsafe {")?;
        self.write_line("            seL4_Yield();")?;
        self.write_line("        }")?;
        self.write_line("    }")?;
        self.write_line("")?;
        self.write_line("}")?;
        Ok(())
    }

    fn write_line(&mut self, line: &str) -> Result<(), Error> {
        self.writer
            .write_all(format!("{}\n", line).as_ref())?;
        Ok(())
    }
}
