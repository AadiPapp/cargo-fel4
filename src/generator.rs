use std::io::Write;

use super::Error;
use cmake_codegen::flags_to_rust_writer;
use cmake_config::RawFlag;
use config::{Arch, Config};

pub struct Generator<'a, 'b, 'c, W: Write + 'a> {
    writer: &'a mut W,
    config: &'b Config,
    cmake_flags: &'c [RawFlag],
}

impl<'a, 'b, 'c, W: Write> Generator<'a, 'b, 'c, W> {
    pub fn new(writer: &'a mut W, config: &'b Config, cmake_flags: &'c [RawFlag]) -> Self
    where
        W: Write,
    {
        Self {
            writer,
            config,
            cmake_flags,
        }
    }

    pub fn generate(&mut self) -> Result<(), Error> {
        {
            writeln!(
                self.writer,
                "
// NOTE: this file is generated by fel4
// NOTE: Don't edit it here; your changes will be lost at the next build!
#![no_std]
#![feature(global_allocator)]
#![feature(alloc)]
extern crate sel4_sys;
extern crate sel4_entry;
extern crate wee_alloc;
extern crate alloc;"
            )?
        }
        writeln!(self.writer, "extern crate {};", self.config.pkg_name)?;

        self.writer.write(
            b"
use core::mem;
use sel4_sys::*;

#[global_allocator]
static ALLOCATOR: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// include the seL4 kernel configurations
#[allow(dead_code)]
#[allow(non_upper_case_globals)]
pub mod sel4_config {\n",
        )?;
        flags_to_rust_writer(self.cmake_flags, self.writer, 4)?;
        self.writer.write(b"}\n\n")?;

        writeln!(
            self.writer,
            r####"#[cfg(feature = "KERNEL_DEBUG_BUILD")]"####
        )?;
        self.writer.write(
            b"
#[inline(always)]
pub fn debug_halt() {
    unsafe { sel4_sys::seL4_DebugHalt() };
}

fn get_untyped(info: &seL4_BootInfo, size_bytes: usize) -> Option<seL4_CPtr> {
    let mut idx = 0;
    for i in info.untyped.start..info.untyped.end {
        if (1 << info.untypedList[idx].sizeBits) >= size_bytes {
            return Some(i);
        }
        idx += 1;
    }
    None
}

const CHILD_STACK_SIZE: usize = 512;
static mut CHILD_STACK: *const [u64; CHILD_STACK_SIZE] =
    &[0; CHILD_STACK_SIZE];

        ",
        )?;

        self.writer.write(
            b"
fn main() {
    let bootinfo = unsafe { &*sel4_entry::BOOTINFO };
    let cspace_cap = seL4_CapInitThreadCNode;
    let pd_cap = seL4_CapInitThreadVSpace;
    let tcb_cap = bootinfo.empty.start;
    let untyped = get_untyped(bootinfo, 1 << seL4_TCBBits).unwrap();
    let retype_err: seL4_Error = unsafe {
        seL4_Untyped_Retype(
            untyped,
            api_object_seL4_TCBObject.into(),
            seL4_TCBBits.into(),
            cspace_cap.into(),
            cspace_cap.into(),
            seL4_WordBits.into(),
            tcb_cap,
            1,
        )
    };
    if retype_err != 0 {
        debug_halt();
    }
    let tcb_err: seL4_Error = unsafe {
        seL4_TCB_Configure(
            tcb_cap,
            seL4_CapNull.into(),
            cspace_cap.into(),
            seL4_NilData.into(),
            pd_cap.into(),
            seL4_NilData.into(),
            0,
            0,
        )
    };
    if tcb_err != 0 {
        debug_halt();
    }
    let stack_base = unsafe { CHILD_STACK as usize };
    let stack_top = stack_base + CHILD_STACK_SIZE;
    let mut regs: seL4_UserContext = unsafe { mem::zeroed() };\n",
        )?;

        match self.config.arch {
            Arch::X86 => {
                writeln!(
                    self.writer,
                    "    regs.rip = {}::run as seL4_Word;",
                    self.config.pkg_name
                )?;
                writeln!(self.writer, "    regs.rsp = stack_top as seL4_Word;")?;
            }
            Arch::Arm => {
                writeln!(
                    self.writer,
                    "    regs.pc = {}::run as seL4_Word;",
                    self.config.pkg_name
                )?;
                writeln!(self.writer, "    regs.sp = stack_top as seL4_Word;")?;
            }
        }
        self.writer.write(
            b"
    let _: u32 =
        unsafe { seL4_TCB_WriteRegisters(tcb_cap, 0, 0, 2, &mut regs) };
    let _: u32 = unsafe {
        seL4_TCB_SetPriority(tcb_cap, seL4_CapInitThreadTCB.into(), 255)
    };
    let _: u32 = unsafe { seL4_TCB_Resume(tcb_cap) };
    loop {
        unsafe {
            seL4_Yield();
        }
    }
}
        ",
        )?;
        Ok(())
    }
}
